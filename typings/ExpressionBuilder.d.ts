import { Expression, ExpressionValue } from './Expression';
import { NotExpression } from './exprs/Not';
import { AndExpression } from './exprs/And';
import { NoExpression } from './exprs/No';
import { DefineExpression } from './exprs/Define';
import { DoExpression } from './exprs/Do';
import { ChainExpression } from './exprs/Chain';
import { CommentExpression } from './exprs/Comment';
import { ComputedExpression } from './exprs/Computed';
import { ConstantExpression } from './exprs/Constant';
import { ForExpression } from './exprs/For';
import { GetExpression } from './exprs/Get';
import { GetTypeExpression } from './exprs/GetType';
import { GetRelationExpression } from './exprs/GetRelation';
import { IfExpression } from './exprs/If';
import { InvokeExpression } from './exprs/Invoke';
import { OperationExpression } from './exprs/Operation';
import { Operation } from './Operation';
import { OrExpression } from './exprs/Or';
import { ReturnExpression } from './exprs/Return';
import { SetExpression } from './exprs/Set';
import { SubExpression } from './exprs/Sub';
import { SwitchExpression } from './exprs/Switch';
import { TemplateExpression } from './exprs/Template';
import { UpdateExpression } from './exprs/Update';
import { WhileExpression } from './exprs/While';
import { TupleExpression } from './exprs/Tuple';
import { ObjectExpression } from './exprs/Object';
import { Type } from './Type';
export declare class ExpressionBuilder {
    cast(valueType: Type, targetType: Type): Expression;
    cast(valueType: Type, targetType: Type, createOnMissing: false): Expression | null;
    and(...exprs: Expression[]): AndExpression;
    body(...exprs: Expression[]): ChainExpression;
    const(value: any): ConstantExpression;
    define(vars?: Record<string, ExpressionValue>, body?: Expression): DefineExpression;
    do(body: Expression, condition?: Expression, breakVariable?: string, maxIterations?: number): DoExpression;
    for(variable: string, start?: ExpressionValue, end?: ExpressionValue, body?: Expression, breakVariable?: string, maxIterations?: number): ForExpression;
    get(...path: ExpressionValue[]): GetExpression;
    sub(value: ExpressionValue, ...path: ExpressionValue[]): SubExpression;
    computed(name: string, value: ExpressionValue): ComputedExpression;
    if(condition: Expression, body?: Expression, otherwise?: Expression): IfExpression;
    invoke(name: string, args?: Record<string, ExpressionValue>): InvokeExpression;
    noop(): NoExpression;
    not(expr: Expression): NotExpression;
    object(props: Record<string, ExpressionValue>): ObjectExpression;
    op<P extends string, O extends string, S extends string>(op: Operation<P, O, S, any, any>, params: Record<P, ExpressionValue> & Partial<Record<O, ExpressionValue>>, scopeAlias?: Partial<Record<S, string>>): OperationExpression<P, O, S>;
    or(...exprs: Expression[]): OrExpression;
    return(value?: ExpressionValue): ReturnExpression;
    set(...path: ExpressionValue[]): SetExpression;
    switch<P extends string, O extends string, S extends string>(value: Expression, op: Operation<P, O, S, any, any>): SwitchExpression;
    template(template: string, params?: Record<string, ExpressionValue>): TemplateExpression;
    tuple(...elements: ExpressionValue[]): TupleExpression;
    update(...path: ExpressionValue[]): UpdateExpression;
    while(condition: Expression, body?: Expression, breakVariable?: string, maxIterations?: number): WhileExpression;
    undefined(): ConstantExpression;
    null(): ConstantExpression;
    true(): ConstantExpression;
    false(): ConstantExpression;
    zero(): ConstantExpression;
    one(): ConstantExpression;
    compareEqual(): ConstantExpression;
    compareLess(): ConstantExpression;
    compareGreater(): ConstantExpression;
    string(): ConstantExpression;
    comment(comment: string): CommentExpression;
    type(name: string): GetTypeExpression;
    relation(name: string): GetRelationExpression;
}
export declare const Exprs: ExpressionBuilder;
