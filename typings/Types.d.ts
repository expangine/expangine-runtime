import { Type, TypeInput, TypeClass, TypeResolved, TypeProvider, TypeInputFor, TypeInputType, TypeInputTypeArray, TypeInputMap, TypeInputTypeElements } from './Type';
import { MapInput } from './fns';
import { NumberType } from './types/Number';
import { AnyType } from './types/Any';
import { BooleanType } from './types/Boolean';
import { DateOptions, DateType } from './types/Date';
import { TextType, TextOptions } from './types/Text';
import { EnumType } from './types/Enum';
import { ObjectType } from './types/Object';
import { ListType } from './types/List';
import { ManyType } from './types/Many';
import { MapType } from './types/Map';
import { NullType } from './types/Null';
import { OptionalInterface } from './types/Optional';
import { TupleType } from './types/Tuple';
import { NotType } from './types/Not';
import { ColorType } from './types/Color';
import { SetType } from './types/Set';
import { EntityType } from './types/Entity';
import { GenericType } from './types/Generic';
import { FunctionType } from './types/Function';
export declare class Types {
    static INDEX: NumberType;
    static LENGTH: NumberType;
    static CHAR: TextType;
    static autoSetParent: boolean;
    static setParent<T extends Type>(type: T, force?: boolean): T;
    static any(): AnyType;
    static bool(trues?: Record<string, true>, falses?: Record<string, true>): BooleanType;
    static date(options?: DateOptions): DateType;
    static entity(name: string, types: TypeProvider): EntityType;
    static enum<K extends TypeInput, V extends TypeInput>(value: V, key?: K, constants?: MapInput): EnumType<TypeInputType<K>, TypeInputType<V>>;
    static enumForText(constants: string[] | Array<[string, string]> | Map<string, string>): EnumType<string, string>;
    static list<I extends TypeInput>(item: I, min?: number, max?: number): ListType<TypeInputType<I>>;
    static many<T extends TypeInput[]>(types: T): ManyType<TypeInputTypeArray<T>>;
    static many<T extends TypeInput[]>(...types: T): ManyType<TypeInputTypeArray<T>>;
    static not(types: TypeInput[]): NotType;
    static not(...types: TypeInput[]): NotType;
    static map<K extends TypeInput, V extends TypeInput>(value: V, key?: K): MapType<TypeInputType<K>, TypeInputType<V>>;
    static null(): NullType;
    static number(min?: number, max?: number, whole?: boolean): NumberType;
    static int(min?: number, max?: number): NumberType;
    static index(max?: number): NumberType;
    static char(): TextType;
    static object<P extends TypeInputMap>(props?: P): ObjectType<import("./Type").UndefinedToOptional<{ [K in keyof P]: TypeInputType<P[K]>; }>, import("./types/Object").ObjectOptions<import("./Type").UndefinedToOptional<{ [K in keyof P]: TypeInputType<P[K]>; }>>>;
    static optional<T extends TypeInput>(type: T): Type<OptionalInterface<TypeInputType<T>>>;
    static color(options?: {
        hasAlpha?: boolean;
    }): ColorType;
    static set<V extends TypeInput>(value: V): SetType<TypeInputType<V>>;
    static text(options?: TextOptions): TextType;
    static tuple<E extends TypeInput[]>(types: E): TupleType<TypeInputTypeElements<E>>;
    static tuple<E extends TypeInput[]>(...types: E): TupleType<TypeInputTypeElements<E>>;
    static generic(path: string[], base?: Type): GenericType;
    static func<P extends TypeInputMap, R extends TypeInput>(types: TypeProvider, params: P, returns?: R): FunctionType<import("./Type").UndefinedToOptional<{ [K in keyof P]: TypeInputType<P[K]>; }>, TypeInputType<R>>;
    static parse<V = any>(input: TypeInputFor<V>): Type<V>;
    static parse<V = any>(input: TypeInputFor<V> | undefined): Type<V> | undefined;
    static simplify(type: Type): Type;
    static simplify(type?: Type): Type | undefined;
    static resolve<T>(types: T): TypeResolved<T>;
    static reduce(type: Type[]): Type;
    static explode(outerType: Type): Type[];
    static maybe<M extends Type>(type: Type | undefined | null, maybe: TypeClass<M>): Type<any, any>;
    static mergeMany(readonlyTypes: Type[]): Type | undefined;
    static mergeMany(readonlyTypes: Type[], noTypes: Type): Type;
    static merge(a: Type, b: Type): Type;
    static coalesce(input: Array<Type | undefined>, otherwise?: Type): Type;
}
