import { Type, TypeInput, TypeClass, TypeResolved, TypeProvider, TypeInputFor, TypeInputMapFor } from './Type';
import { MapInput } from './fns';
import { NumberType } from './types/Number';
import { AnyType } from './types/Any';
import { BooleanType } from './types/Boolean';
import { DateOptions, DateType } from './types/Date';
import { TextType, TextOptions } from './types/Text';
import { EnumType } from './types/Enum';
import { ObjectType } from './types/Object';
import { ListType } from './types/List';
import { ManyType } from './types/Many';
import { MapType } from './types/Map';
import { NullType } from './types/Null';
import { TupleType } from './types/Tuple';
import { NotType } from './types/Not';
import { ColorType } from './types/Color';
import { SetType } from './types/Set';
import { EntityType } from './types/Entity';
import { GenericType } from './types/Generic';
import { FunctionType } from './types/Function';
export declare class Types {
    static INDEX: NumberType;
    static LENGTH: NumberType;
    static CHAR: TextType;
    static autoSetParent: boolean;
    static setParent<T extends Type>(type: T, force?: boolean): T;
    static any(): AnyType;
    static bool(trues?: Record<string, true>, falses?: Record<string, true>): BooleanType;
    static date(options?: DateOptions): DateType;
    static entity(name: string, types: TypeProvider): EntityType;
    static enum<K = any, V = any>(value: TypeInputFor<V>, key?: TypeInputFor<K>, constants?: MapInput): EnumType<K, V>;
    static enumForText(constants: string[] | Array<[string, string]> | Map<string, string>): EnumType<string, string>;
    static list<I = any>(item: TypeInputFor<I>, min?: number, max?: number): ListType<I>;
    static many(types: TypeInput[]): ManyType;
    static many(...types: TypeInput[]): ManyType;
    static not(types: TypeInput[]): NotType;
    static not(...types: TypeInput[]): NotType;
    static map<K = string, V = any>(value: TypeInputFor<V>, key?: TypeInputFor<K>): MapType<K, V>;
    static null(): NullType;
    static number(min?: number, max?: number, whole?: boolean): NumberType;
    static int(min?: number, max?: number): NumberType;
    static index(max?: number): NumberType;
    static char(): TextType;
    static object<O = any>(props?: TypeInputMapFor<O>): ObjectType<O, import("./types/Object").ObjectOptions<O>>;
    static optional<T = any>(type: TypeInputFor<T>): Type<T | undefined | null>;
    static color(options?: {
        hasAlpha?: boolean;
    }): ColorType;
    static set<V = any>(value: TypeInputFor<V>): SetType<V>;
    static text(options?: TextOptions): TextType;
    static tuple<E extends any[]>(types: TypeInputMapFor<E>): TupleType;
    static tuple<E extends any[]>(...types: TypeInputMapFor<E>): TupleType;
    static generic(path: string[], base?: Type): GenericType;
    static func<P = any, R = any>(types: TypeProvider, params: TypeInputMapFor<P>, returns?: TypeInputFor<R>): FunctionType<P, R>;
    static parse<V = any>(input: TypeInputFor<V>): Type<V>;
    static simplify(type: Type): Type;
    static simplify(type: Type | null): Type | null;
    static resolve<T>(types: T): TypeResolved<T>;
    static reduce(type: Type[]): Type;
    static explode(outerType: Type): Type[];
    static maybe<M extends Type>(type: Type, maybe: TypeClass<M>): Type<any, any>;
    static mergeMany(readonlyTypes: Type[]): Type | null;
    static mergeMany(readonlyTypes: Type[], noTypes: Type): Type;
    static merge(a: Type, b: Type): Type;
    static coalesce(input: Type[], otherwise?: Type): Type;
}
